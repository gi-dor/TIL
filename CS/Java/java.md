1.[JavaSE , JavaEE 애플리케이션 차이](#java-se-와-java-ee-애플레키이션-차이)
2.[Java 와 C, C++](#java-와-c--c-의-차이점)
3.[Java 장단점](#java-의-장단점)
4.[Java 컴파일 과정](#자바-컴파일과정)
5.[접근 제어자](#접근 제어자)
6.[데이터 타입](#데이터 타입)

### Java SE 와 Java EE 애플레키이션 차이

- Java SE (Standard Edition)
    - Java의 기본 플랫폼으로 , 데스크탑 애플리케이션 개발하는데 주로 사용
    - 기본 클래스 라이브러리 : java.lang , java.util , java.io 등의 기본 패키지

- Java EE (Enterprise Edition)
    - Java SE를 기반으로 확장된 플랫폼
    - 이식 가능 , 확장 가능
    - 웹 애플리케이션 , 분산 시스템 등을 구축하는데 필요한 API와 서비스를 제공
        - Servlet , JSP : 웹 애플리케이션 개발을 위한 기술
        - JPA (Java Persistance API): 객체 - 관계 매핑을 위한 API
        - JMS (Java Message Service): 메세지 기반의 통신
        - Web Service : RESTful 웹 서비스 구현

    - Java SE는 기본적인 애플리케이션 개발 , Java EE는 대규모 엔터프라이즈 애플리케이션 개발을 위한 플랫폼

<br>

### Java 와 C , C++ 의 차이점

- Java 와 C , C++ 차이점은 실행환경이다
- Java 에서 개발 : 컴파일 또는 컴파일 + jar파일 압축
    - Java는 링크 과정이 없이 컴파일러가 바로 바이트 코드를 생성
- C , C++ : 컴파일 + 링크

<br>

### 자바 컴파일과정

1. 자바 소스 코드 작성 , 해당 코드는 `.java` 파일로 저장
2. `javac` 컴파일러가 `.java` 파일을 읽고 컴파일 과정을 통해 `.class` 파일을 생성
3. 코드의 해당 명령어를 실행하면 JVM이 `.class` 파일을 로드하고 바이트 코드를 실행해 콘솔에 표시

<br>

### Java 의 장단점

- 장점
    - 운영체제에 독립적이다
        - JVM 에서 동작하기 때문에 특정 운영체제에 종속되지 않는다
    - 객체지향 언어
        - 객체지향적으로 프로그래밍 하기위해 여러 언어적 지원을 하고있다
          (캡슐 , 상속 , 추상화 , 다형성)
    - 자동으로 메모리 관리를 해준다
        - JVM에서 Garbage Collector이라고 불리는 데몬 쓰레드에 의해 GC(Gabage Collection)가 일어난다. GC로 인해 별도의 메모리 관리가 필요 없어
          비즈니스 로직에 집중 할 수 있다
    - 오픈소스
        - 정확하게 표현한다면 OpenJDK가 오픈소스이다.
        - 많은 오픈소스 라이브러리가 풍부하며 ,짧은 개발시간내에 안정적인 애플리케이션을 쉽게 구현할 수 있다
    - 멀티쓰레드 쉽게 구현
        - Java는 스레드 생성 , 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 , 실행되는
          운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다

- 단점
    - 비교적 속도가 느리다
        - Java는 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 C , C++ 의 컴파일 단계에서
          만들어지는 완전한 기계어 보다는 속도가 느리다
    - 예외처리의 불편함
        - 프로그래머가 검사가 필요한 예외가 등장한다면 프로그래머가 선언 해줘야 한다

<br> 

### 접근 제어자

    클래스 , 메서드 , 변수 등에 대한 접근권한을 설정하는 키워드

| 접근 제어자      | 같은 클래스 | 같은 패키지 | 자식 클래스 | 전체 접근 |
|-------------|--------|--------|--------|-------|
| `public`    | O      | O      | O      | O     |
| `protected` | O      | O      | O      | X     |
| `default`   | O      | O      | X      | X     |
| `private`   | O      | X      | X      | X     |

1. public : 어디서나 접근이 가능하도록 허용
2. protected : 같은 패키지 내의 클래스 , 다른 패키지에있는 자식 클래스에서 접근이 가능
3. (default) : 같은 패키지 내의 클래스에서만 접근
4. private : 같은 클래스 내에서만 접근이 가능하도록 허용

<br>

### 데이터 타입

1. 기본 데이터 타입
    - 정수형 : byte , short , int , long
    - 실수형 : float , double
    - 논리형 : boolean
    - 문자형 : char

2. 참조 타입
    - 기본형을 제외하고는 모두 참조형
    - new 키워드를 이용해 객체를 생성해 데이터가 생성된 주소를 참조하는 타입
    - String , StringBuffer , StringBuilder , List 개인이 만든 클래스
    - String 과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 참조 타입이다

<br>

### Wrapper class

프로그램에 따라 기본타입의 데이터를 객체로 취급해야하는 경우가 있다.
기본 타입의 데이터를 그대로 사용할수 없다면 , 이떄 기본 타입의 데이터를 객체로 변환 후 작업을 수행한다

| 기본 타입     | 래퍼 클래스      |
|-----------|-------------|
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `char`    | `Character` |
| `boolean` | `Boolean`   |

기본타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 래퍼클래스 Wrapper class 라고 한다.

🔸 래퍼 클래스는 산술연산을 위해 정의된 클래스가 아니므로 , 인스턴스에 저장된 값을 변경할 수 없다 .
단지 값을 참조하기 위해 새로운 인스턴스를 생성하고 , 생성된 인스턴스의 값만을 참조한다.

<br>

### 객체지향 설계 5원칙

SOLID 원칙

1. SRP : 단일 책임원칙
    - 하나의 클래스는 하나의 책임만 가져야한다
2. OCP : 개방폐쇄 원칙
    - 확장에는 열려있고 , 변경에는 닫혀 있는다
3. LSP : 리스코프 치환
    - 자식 클래스는 언제든지 부모클래스를 대체할 수 있어야 한다
4. ISP : 인터페이스 분리
    - 자신이 사용하지 않는 인터페이스는 구현하지 않는다 , 영향을 받아서도 안된다
5. DIP : 의존 역전
    - 자주 변화하는 것보다 변화가 거의 없는 것에 의존해야한다

<br>

### 객체지향 프로그래밍 , 절차지향 프로그래밍

- 객체지향 프로그래밍
    - 실제의 물체를 객체로 표현하고 , 이들 사이의 관계 , 상호 작용을 프로그램으로 나타낸다
    - 객체를 추출하고 관계를 결정하고 , 상호작용에 필요한 메서드와 , 변수를 설계 및 구현
- 절차지향 프로그래밍
    - 실행하고자 하는 절차를 정하고 , 절차대로 프로그래밍 하는 방법
    - 목적을 달성하기 위한 일의 흐름에 중점을 둔다

<br>

### 객제지향

- 객체
    - 현실세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합


- 객체지향 장점
    - 사람의 관점에서 프로그램을 이해하고 파악하기 쉽다
    - 강한 응집력 , 약한 결합력
    - 재사용성 , 확장성 , 융통성이 높다
- 객체지향 단점
    - 처리속도가 상대적으로 느리다
    - 객체가 상태를 갖기에 부작용이 발생할수 있다
        - 변수가 존재하고 , 변수를 통해 객체가 예측할 수 없는 상태를 갖게되어 애플리케이션 내부에서 버그를 발생

### 객체지향 특징

- 캡슐화
    - 객체의 데이터(속성)과 데이터를 조작하는 메서드를 하나로 묶은 것
    - 객체의 내부상태를 외부에서 직접 접근하지 못하도록 하고 , 객체의 상태는 객체의 메서드를 통해서만 변경될 수 있다
    - 데이터 접근제한 , 필요한 경우 메서드를 통해 접근허용
    - 정보 은닉
        - 내부의 데이터나 함수를 감추고 외부에서 필요한 정보나 기능만을 노출 하는것을 의미
            - 내부상태 , 구현 세부사항 숨김
            - private 으로 선언한 변수에 직접 접근을 제한하고 `getter` 와 `setter` 메서드를 통해서만 접근
    - 캡슐화는 변수와 메서드를 하나의 단위로 묶는 개념
    - 정보은닉은 객체의 내부구현 , 세부사항을 감추고 , 외부에는 필요한 인터페이스만 노출 `gettet`,`setter` 로만 접근

- 상속
    - 부모 클래스의 변수와 메서드를 그대로 활용할 수 있다
    - 오버로딩 : 같은 클래스 내의 같은 이름의 메서드를 여러개 정의
        - 조건
            - 메서드 명이 같아야한다
            - 매개변수 갯수 또는 타입이 달라야한다
            - 리턴타입이 다른경우 성립되지 않는다
    - 오버라이딩 : 상속 받은 부모클래스에서 정의된 메서드를 자식 클래스에서 재정의
        - 부모 클래스의 메서드를 재정의하면 자식 클래스의 메서드가 된다
        - @Override 어노테이션을 사용 , 오버라이딩을 검증하는 기능을한다
        - 조건
            - 부모클래스의 메서드와 메서드명이 동일
            - 매개변수의 타입 , 갯수 , 순서가 일치
            - 리턴 타입이 동일
            - 접근제한자는 부모클래스의 메서드와 같거나 더 넓은 범위어야 한다
- 추상화
- 다형성