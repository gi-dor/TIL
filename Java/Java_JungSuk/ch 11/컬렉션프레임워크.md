### [ LinkedList ] - 배열의 장단점

장점 : 배열의 구조가 간단함 , 데이터를 읽는데 걸리는 시간이 짧다(접근시간) 

단점 1️⃣ 배열 생성후 크기 변경이 불가능함

* 크기를 변경 해야할 경우 : 새로운 배열을 생성 후 데이터를 복사 해야함
* 크기 변경을 피하기 위해 시작부터 큰 배열을 생성하게되면 메모리가 낭비됨.

단점 2️⃣ 비순차적인 데이터의 추가 , 삭제에 시간이 많이걸린다
* 순차적인 데이터 추가 (끝에서 부터 추가)
* 순차적인 데이터 삭제 (끝에서부터 삭제)  는 빠르다

-----

### [ LinkedList 추가와 삭제 ]

배열의 단점을 보완

배열과 달리 LinkedList는 불연속적으로 존재하는 데이터를 연결

▶ 데이터 삭제  - 단 한번의 참조변경만으로 가능

![20230403_172518](https://user-images.githubusercontent.com/86302876/229456155-de747583-a458-4ff9-a266-5ee10e34509b.jpg)


▶ 데이터 추가 - 한번의 Node객체 생성과 두번의 참조변경 만으로 가능

![20230403_172859](https://user-images.githubusercontent.com/86302876/229456040-ab2a2e32-d575-4624-a354-77edbd9101b1.jpg)

------

### [ 이중 연결 리스트 ]


▶ 더블리 링크드 리스트 - 이중연결 리스트 - 접근성 향상


![1111111](https://user-images.githubusercontent.com/86302876/229460091-8e03aec1-817a-4934-a80a-161c1dc01cf1.jpg)


▶ 더블리 써큘러 링크드 리스트 - 이중원형 리스트


![2222222222222](https://user-images.githubusercontent.com/86302876/229460149-052f0d0d-19d2-4223-987f-97952a86511c.jpg)

-----

### [ ArrayList 와 LinkedList  의 성능 비교 ]
 
 
 ![333333333](https://user-images.githubusercontent.com/86302876/229464966-bcccbbc2-145e-43d4-a652-62ded0a0b87b.jpg)
 
 
 
      인덱스가 n 인 데이터의 주소 
      = 배열의 주소 + n * 데이터 타입의 크기 
      // n 은 n번째 요소를 뜻함

-----
### Srack , Queue

![Stack Queue](https://user-images.githubusercontent.com/86302876/229718636-ac13b674-780b-4a93-8dbf-5c2f2e3363d7.jpg)


▶ Stack : 마지막에 저장된 것을 제일 먼저 꺼낸다

                 0 , 1 , 2 저장 =>  2 , 1 , 0 출력
▶ Queue : 가장 먼저 저장한것을 먼저 꺼낸다 

                 0 , 1 , 2 저장 => 0 , 1 , 2 출력
                 

Stack 주요 메서드

* boolean empty ()  Stack이 비어있는지 확인
* Object peek ()  Stack에 맨위 저장된 객체를 반환  // 비어 있으면 Exception 발생
* Object pop ( ) Stack 맨위에 저장된 객체를 꺼냄 // 비어 있으면  EmptyStack Exception 발생
* Object push()  Stack에 객체 저장

Queue 주요 메서드

* boolean add ( )  지정된 객체를 Queue에 추가  , 성공하면 true 실패 false 반환 
* Object remove ()  삭제 //  비어있으면  NoSuchElmentException 발생
* boolean offer ()  Queue에 객체를 저장 // true ,false 반환
* Object poll ( ) 삭제 // 예외 발생 x
* Object peek ( ) 삭제 없이 요소를 읽어옴  Queue가 비어있다면 null 반환

-----

### Iterator

     Itertor -   컬렉션에 저장된 요소를 접근하는데 쓰이는 인터 페이스   
     ListIterator  -  Iterator에 양방향 조회 기능을 추가함 ↔
     Enumeration - Iterator 구버전

주요 메서드

boolean hasNext()   - 확인

읽어올 요소가 남이있는지 확인 // 있다면 true  없다면 false

Object next() - 읽기

next() 를 호출하기전에 hasNext() 를 호출해서 읽어올 요소가 있는지 확인후 사용

-----

### Arrays 메서드

     	// Arrays 의 메서드 
      //		static String toString (boolean[] a)
      //		static String toString (byte[] a)
      //		static String toString (char[] a)
      //		static String toString (short[] a)
      //		static String toString (int[] a)
      //		static String toString (long[] a)
      //		static String toString (float[] a)
      //		static String toString (double[] a)
      //		static String toString (Object[] a)
		
		// 복사 copyOf() , copyOfRange()
		int [] arr = { 0,1,2,3,4};
		int[] arr1 = Arrays.copyOf(arr, arr.length); // arr1 = 0
		int[] arr2 = Arrays.copyOf(arr, 3); // arr2 = 0 1 2
		int[] arr3 = Arrays.copyOf(arr, 7); // arr3 = 0 1 2 3 4  0 0  나머지 부분은 0 으로 채움
		int[] arr4 = Arrays.copyOfRange(arr, 2 , 4); // 2from ~ 4 to   2 <= x <4
		int[] arr5 = Arrays.copyOfRange(arr, 0 ,7); //  0 1 2 3 4 0 0
		
		// 배열채우기 filll()  setAll()
		int[] arr = new int [5];
		Arrays.fill(arr, 9);  // arr [ 9 9 9 9]
		Arrays.setAll(arr,  (i)-> (int)(Math.random()*5)+1); // arr [ 1 ~ 4 랜덤난수 ]  1<=x<5
		
		 // 배열의 정렬과 검색 -sort() binarySearch() 
		int [] arr = {3,2,0,1,4};
		int index = Arrays.binarySearch(arr, 2); // 정렬이 안되있어서 잘못된 결과가 나옴
		
		Arrays.sort(arr); // 배열 arr 정렬
		System.out.println(Arrays.toString(arr)); // 0 1 2 3 4
		int index = Arrays.binarySearch(arr, 2); //  
		
		// 비교와 출력 - equals() , toString()
		int[] arr = {0,1,2,3,4};
		int [][] arr2D = { {11,12,13} , {14,15,16} };
		
		System.out.println(Arrays.toString(arr)); // 0 1 2 3 4
		// toString 은 일차원 배열에만 사용 할수 있다
		
		System.out.println(Arrays..deeoToString(arr2D)); // 11,12,13  14,15,16
		// deepToString은 다차원 배열에 사용
		
		
		String [][] str2D = new String[][] { {"aaa","bbb"} , {"AAA","BBB"} };
		String [][] str2D2 = new String[][] { {"aaa","bbb"} , {"AAA","BBB"} };
		
		System.out.println(Arrays.equals(str2D, str2D2));  //false 
		// 문자열을 비교하는게 아닌 배열에 저장된 배열의 주소를 비교함 
		
		 System.out.println(Arrays.deepEquals(str2D, str2D2); // true
		
		
		
		// 배열을 List로변환 - asList()
		 // asList()는 배열을 List에 담아서 반환 
		List list = Arrays.asList(new Integer[] { 1,2,3,4,5 } );  // list = 1,2,3,4,5
		List list = Arrays.asList(1,2,3,4,5);  // list = 1,2,3,4,5
		


